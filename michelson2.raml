exception Invalid_argument

type ct =
  Int of int | Bool of bool
and t =
  Ct of ct | Unit | None | Some of t | Set of ct list | Operation of int list |
  Pair of t * t


let rec seq (body:(t list -> t list) list) s =
  match body with
  | [] -> s
  | op :: l -> seq l (op s)


let if_ bt bf (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Bool b  -> if b then bt xs else bf xs
    | _ -> raise Invalid_argument
  end


let rec loop body s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Bool true -> loop body (seq body xs)
    | Ct Bool false -> xs
    | _ -> raise Invalid_argument
  end


let rec dip n code (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs ->
    if n = 0 then seq code s else x :: dip (n - 1) code xs


let rec dip n code (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs ->
    if n = 0 then seq code s else x :: dip (n - 1) code xs


let rec drop n (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | _ :: xs ->
    if n = 0 then s else begin
      if n = 1 then xs else drop (n - 1) xs
    end

let dup (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> x :: x :: xs


let swap (s:t list) =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> y :: x :: xs


let rec append l1 l2 =
  match l1 with
  | [] -> l2
  | x::xs -> x::(append xs l2)

let rec dig_aux n (s':t list) (s:t list)=
  if n = 0 then begin
    match s with
    | [] -> []
    | x :: xs -> append (x :: s') xs
  end else begin
    match s with
    | [] -> raise Invalid_argument
    | _ :: [] -> raise Invalid_argument
    | x :: y :: xs -> dig_aux (n - 1) (append s' [x]) (y :: xs)
  end

let dig n s = dig_aux n [] s


let rec dug n (s:t list) =
  if n = 0 then s else begin
    match s with
    | [] -> raise Invalid_argument
    | _ :: [] -> raise Invalid_argument
    | x :: y :: xs -> y :: dug (n - 1) (x :: xs)
  end


let push (x:t) (s:t list) =  x :: s


let unit s = Unit :: s


let eq s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i = 0 then Ct (Bool true) :: xs else Ct (Bool false) :: xs
    | _ -> raise Invalid_argument
  end


let neq s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i = 0 then Ct (Bool false) :: xs else Ct (Bool true) :: xs
    | _ -> raise Invalid_argument
  end



let lt s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i < 0 then Ct (Bool true) :: xs else Ct (Bool false) :: xs
    | _ -> raise Invalid_argument
  end


let gt s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i > 0 then Ct (Bool true) :: xs else Ct (Bool false) :: xs
    | _ -> raise Invalid_argument
  end


let le s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i <= 0 then Ct (Bool true) :: xs else Ct (Bool false) :: xs
    | _ -> raise Invalid_argument
  end


let ge s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i >= 0 then Ct (Bool true) :: xs else Ct (Bool false) :: xs
    | _ -> raise Invalid_argument
  end


let or_ s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Bool bx, Ct Bool by -> Ct (Bool (bx || by)) :: xs
    | _ -> raise Invalid_argument
  end


let and_ s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Bool bx, Ct Bool by -> Ct (Bool (bx && by)) :: xs
    | _ -> raise Invalid_argument
  end


let xor s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Bool bx, Ct Bool by -> Ct (Bool ((bx || by) && (not bx || not by))) :: xs
    | _ -> raise Invalid_argument
  end


let not s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Bool b -> Ct (Bool (not b)) :: xs
    | _ -> raise Invalid_argument
  end


let neg s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i -> Ct (Int (-i)) :: xs
    | _ -> raise Invalid_argument
  end


let abs s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Ct Int i ->
      if i >= 0 then Ct (Int i) :: xs else Ct (Int (-i)) :: xs
    | _ -> raise Invalid_argument
  end

let add s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Int ix, Ct Int iy -> Ct (Int (ix + iy)) :: xs
    | _ -> raise Invalid_argument
  end


let mul s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Int ix, Ct Int iy -> Raml.tick 1.0; Ct (Int (ix * iy)) :: xs
    | _ -> raise Invalid_argument
  end


let ediv s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Int ix, Ct Int iy -> begin
      if iy = 0 then None :: xs else Some (Pair (Ct (Int (ix / iy)), Ct (Int (ix mod iy)))) :: xs
    end
    | _ -> raise Invalid_argument
  end


let compare s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Ct Int ix, Ct Int iy -> begin
      if ix < iy then Ct (Int (-1)) :: xs else begin
        if ix = iy then Ct (Int 0) :: xs else Ct (Int 1) :: xs
      end
    end
    | _ -> raise Invalid_argument
  end


let pair s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs ->  Pair (x, y) :: xs


let car s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Pair (a, _) -> a :: xs
    | _ -> raise Invalid_argument
  end


let cdr s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Pair (_, b) -> b :: xs
    | _ -> raise Invalid_argument
  end


let compare_pair s =
  match s with
  | [] -> raise Invalid_argument
  | _ :: [] -> raise Invalid_argument
  | x :: y :: xs -> begin
    match x, y with
    | Pair (xa, xb), Pair (ya, yb) -> begin
      match xa, xb, ya, yb with
      | Ct Int ixa, Ct Int ixb, Ct Int iya, Ct Int iyb -> begin
        if ixa = iya then compare (xb :: yb :: xs) else compare (xa :: ya :: xs)
      end
      | _ -> raise Invalid_argument
    end
    | _ -> raise Invalid_argument
  end

let nilop s = Operation [] :: s


(*let rec iter (body:element list -> element list) s =
  match s with
  | [] -> raise Invalid_argument
  | x :: xs -> begin
    match x with
    | Listi li -> begin
      match li with
      | [] -> xs
      | hd :: tl ->
        iter body (Listi tl :: body (Elmi hd :: xs))
    end
    | Listb lb -> begin
      match lb with
      | [] -> xs
      | hd :: tl ->
        iter body (Listb tl :: body (Elmb hd :: xs))
    end
    | _ -> raise Invalid_argument
  end*)


let sum_aux s =
  seq [push (Ct (Int (-1))); add; dup; dip 1 [add]; dup; gt] s

let sum p s =
  seq
  [car; dup; dup; gt; loop [push (Ct (Int (-1))); add; dup; dip 1 [add]; dup; gt];
  drop 1; nilop; pair]
  (Pair (Ct (Int p), Ct (Int s)) :: [])

let _ = sum 10 0

(*let _ = sum_aux [Elmi 10; Elmi 10]*)

exception Invalid_argument

type ct =
  Int of int | Nat of Rnat.t | String | Mutez of Rnat.t | Bool of bool | Keyhash of int |
  Timestamp of int | Address of int

and t =
  Ct of ct | Unit | None | Some of t | Set of ct list | Operation | Contract of t | TPair of t * t

and stack =
  T of t | List of t list | Pair of stack * stack | Failed


let failwith s = Failed :: []

let rec seq body s =
  match body with
  | [] -> s
  | op :: l -> seq l (op s)


let if_ bt bf s =
  match s with
  | T Ct Bool b :: xs -> if b then seq bt xs else seq bf xs
  | _ ->  Failed :: []


let rec loop_aux n body s =
  Rnat.ifz n
    (fun () -> s)
    (fun n' ->
      let s' = seq body s in
      match s' with
      | T Ct Bool b :: xs -> if b then loop_aux n' body xs else xs
      | _ -> Failed :: [])


let loop n body s =
  match s with
  | T Ct Bool b :: xs -> if b then loop_aux n body xs else xs
  | _ -> Failed :: []


let dip1 code s =
  match s with
  | [] | Failed :: _ -> Failed :: []
  | x :: xs -> x :: seq code xs

let rec dip n code s =
  Rnat.ifz n
    (fun () -> code s)
    (fun n' ->
      match s with
      | [] | Failed :: _ -> Failed :: []
      | x :: xs -> x :: dip n' code xs)

let drop1 s=
  match s with
  | [] | Failed :: _ -> Failed :: []
  | _ :: xs -> xs


let rec drop n s =
  match s with
  | [] | Failed :: _ -> Failed :: []
  | _ :: xs ->
    Rnat.ifz n
      (fun () -> s)
      (fun n' -> drop n' xs)


let dup s =
  match s with
  | [] | Failed :: _ -> Failed :: []
  | x :: xs -> x :: x :: xs


let swap s =
  match s with
  | Failed :: _ -> Failed :: []
  | x :: y :: xs -> y :: x :: xs
  | _ -> Failed :: []


let rec append l1 l2 =
  match l1 with
  | [] -> l2
  | x::xs -> x::(append xs l2)

let rec dig_aux n s' s =
  Rnat.ifz n
    (fun () -> begin
      match s with
      | [] | Failed :: _ -> Failed :: []
      | x :: xs -> append (x :: s') xs
    end)
    (fun n' -> begin
      match s with
      | [] | Failed :: _ -> Failed :: []
      | x :: xs -> dig_aux n' (append s' [x]) xs
    end)

let dig n s = dig_aux n [] s


let rec dug n s =
  Rnat.ifz n
    (fun () -> s)
    (fun n' -> begin
      match s with
      | Failed :: _ -> Failed :: []
      | x :: y :: xs -> y :: dug n' (x :: xs)
      | _ -> Failed :: []
    end)


let push (x:stack) (s:stack list) =
  match s with
  | Failed :: _ -> Failed :: []
  | _ -> x :: s


let unit s =
  match s with
  | Failed :: _ -> Failed :: []
  | _ -> T Unit :: s


let eq s =
  match s with
  | T Ct Int i :: xs ->
    if i = 0 then T (Ct (Bool true)) :: xs else T (Ct (Bool false)) :: xs
  | _ -> Failed :: []


let neq s =
  match s with
  | T Ct Int i :: xs ->
    if i = 0 then T (Ct (Bool false)) :: xs else T (Ct (Bool true)) :: xs
  | _ -> Failed :: []


let lt s =
  match s with
  | T Ct Int i :: xs ->
    if i < 0 then T (Ct (Bool true)) :: xs else T (Ct (Bool false)) :: xs
  | _ -> Failed :: []


let gt s =
  match s with
  | T Ct Int i :: xs ->
    if i > 0 then T (Ct (Bool true)) :: xs else T (Ct (Bool false)) :: xs
  | _ -> Failed :: []


let le s =
  match s with
  | T Ct Int i :: xs ->
    if i <= 0 then T (Ct (Bool true)) :: xs else T (Ct (Bool false)) :: xs
  | _ -> Failed :: []


let ge s =
  match s with
  | T Ct Int i :: xs ->
    if i >= 0 then T (Ct (Bool true)) :: xs else T (Ct (Bool false)) :: xs
  | _ -> Failed :: []


let or_ s =
  match s with
  | T Ct Bool bx :: T Ct Bool by :: xs -> T (Ct (Bool (bx || by))) :: xs
  | _ -> Failed :: []


let and_ s =
  match s with
  | T Ct Bool bx :: T Ct Bool by :: xs -> T (Ct (Bool (bx && by))) :: xs
  | _ -> Failed :: []


let xor s =
  match s with
  | T Ct Bool bx :: T Ct Bool by :: xs -> T (Ct (Bool ((bx || by) && (not bx || not by)))) :: xs
  | _ -> Failed :: []


let not_ s =
  match s with
  | T Ct Bool b :: xs -> T (Ct (Bool (not b))) :: xs
  | _ ->  Failed :: []


let neg s =
  match s with
  | T Ct Int i :: xs -> T (Ct (Int (-i))) :: xs
  | T Ct Nat i :: xs -> T (Ct (Int (-(Rnat.to_int i)))) :: xs
  | _ -> Failed :: []


let abs s =
  match s with
  | T Ct Int i :: xs ->
    if i >= 0 then T (Ct (Nat (Rnat.of_int i))) :: xs else T (Ct (Nat (Rnat.of_int(-i)))) :: xs
  | _ -> Failed :: []


let isnat s =
  match s with
  | T Ct Int i :: xs ->
    if i >= 0 then T (Some (Ct (Nat (Rnat.of_int i)))) :: xs else T None :: xs
  | _ -> Failed :: []


let int s =
  match s with
  | T Ct Nat i :: xs -> T (Ct (Int (Rnat.to_int i))) :: xs
  | _ -> Failed :: []


let add s =
  match s with
  | T Ct Int ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix + iy))) :: xs
  | T Ct Int ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix + (Rnat.to_int iy)))) :: xs
  | T Ct Nat ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int ((Rnat.to_int ix) + iy))) :: xs
  | T Ct Nat ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Nat (Rnat.add ix iy))) :: xs
  | T Ct Timestamp tx :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Timestamp (tx + iy))) :: xs
  | T Ct Int ix :: T Ct Timestamp ty :: xs -> Raml.tick(1.0); T (Ct (Timestamp (ix + ty))) :: xs
  | T Ct Mutez mx :: T Ct Mutez my :: xs -> Raml.tick(1.0); T (Ct (Mutez (Rnat.add mx my))) :: xs
  | _ -> Failed :: []


let sub s =
  match s with
  | T Ct Int ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix - iy))) :: xs
  | T Ct Int ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix - (Rnat.to_int iy)))) :: xs
  | T Ct Nat ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int ((Rnat.to_int ix) - iy))) :: xs
  | T Ct Nat ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Int ((Rnat.to_int ix) - (Rnat.to_int iy)))) :: xs
  | T Ct Timestamp tx :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Timestamp (tx - iy))) :: xs
  | T Ct Timestamp tx :: T Ct Timestamp ty :: xs -> Raml.tick(1.0); T (Ct (Timestamp (tx - ty))) :: xs
  | T Ct Mutez mx :: T Ct Mutez my :: xs -> Raml.tick(1.0);
    let (m, _) = Rnat.minus mx my in T (Ct (Mutez m)) :: xs
  | _ -> Failed :: []


let mult s =
  match s with
  | T Ct Int ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix * iy))) :: xs
  | T Ct Int ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Int (ix * (Rnat.to_int iy)))) :: xs
  | T Ct Nat ix :: T Ct Int iy :: xs -> Raml.tick(1.0); T (Ct (Int ((Rnat.to_int ix) * iy))) :: xs
  | T Ct Nat ix :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Nat (Rnat.mult ix iy))) :: xs
  | T Ct Mutez mx :: T Ct Nat iy :: xs -> Raml.tick(1.0); T (Ct (Mutez (Rnat.mult mx iy))) :: xs
  | T Ct Nat ix :: T Ct Mutez my :: xs -> Raml.tick(1.0); T (Ct (Mutez (Rnat.mult ix my))) :: xs
  | _ -> Failed :: []

let ediv s =
  match s with
  | T Ct Int ix :: T Ct Int iy :: xs ->
    if iy = 0 then T None :: xs else T (Some (TPair (Ct (Int (ix / iy)), Ct (Nat (Rnat.of_int (ix mod iy)))))) :: xs
  | T Ct Int ix :: T Ct Nat iy :: xs ->
    Rnat.ifz iy
      (fun () -> T None :: xs)
      (fun n' -> T (Some (TPair (Ct (Int (ix / (Rnat.to_int iy))), Ct (Nat (Rnat.of_int (ix mod (Rnat.to_int iy))))))) :: xs)
  | T Ct Nat ix :: T Ct Int iy :: xs ->
    if iy = 0 then T None :: xs else T (Some (TPair (Ct (Int ((Rnat.to_int ix) / iy)), Ct (Nat (Rnat.of_int ((Rnat.to_int ix) mod iy)))))) :: xs
  | T Ct Nat ix :: T Ct Nat iy :: xs ->
    Rnat.ifz iy
      (fun () -> T None :: xs)
      (fun n' -> let (d, m, _) = Rnat.div_mod ix iy in T (Some (TPair (Ct (Nat d), Ct (Nat m)))) :: xs)
  | T Ct Mutez mx :: T Ct Nat iy :: xs ->
    Rnat.ifz iy
      (fun () -> T None :: xs)
      (fun n' -> let (d, m, _) = Rnat.div_mod mx iy in T (Some (TPair (Ct (Mutez d), Ct (Mutez m)))) :: xs)
  | T Ct Mutez mx :: T Ct Mutez my :: xs ->
    Rnat.ifz my
      (fun () -> T None :: xs)
      (fun n' -> let (d, m, _) = Rnat.div_mod mx my in T (Some (TPair (Ct (Nat d), Ct (Mutez m)))) :: xs)
  | _ -> Failed :: []


let rec compare s =
  match s with
  | T Ct Int ix :: T Ct Int iy :: xs -> begin
    if ix < iy then T (Ct (Int (-1))) :: xs else begin
      if ix = iy then T (Ct (Int 0)) :: xs else T (Ct (Int 1)) :: xs
    end
  end
  | T Ct Nat ix :: T Ct Nat iy :: xs -> begin
    if Rnat.to_int ix < Rnat.to_int iy then T (Ct (Int (-1))) :: xs else begin
      if Rnat.to_int ix = Rnat.to_int iy then T (Ct (Int 0)) :: xs else T (Ct (Int 1)) :: xs
    end
  end
  | T Ct Timestamp tx :: T Ct Timestamp ty :: xs -> begin
    if tx < ty then T (Ct (Int (-1))) :: xs else begin
      if tx = ty then T (Ct (Int 0)) :: xs else T (Ct (Int 1)) :: xs
    end
  end
  | T Ct Mutez mx :: T Ct Mutez my :: xs -> begin
    if Rnat.to_int mx < Rnat.to_int my then T (Ct (Int (-1))) :: xs else begin
      if Rnat.to_int mx = Rnat.to_int my then T (Ct (Int 0)) :: xs else T (Ct (Int 1)) :: xs
    end
  end
  | _ -> Failed :: []


let pair s =
  match s with
  | Failed :: _ -> Failed :: []
  | x :: y :: xs ->  Pair (x, y) :: xs
  | _ -> Failed :: []


let car s =
  match s with
  | Pair (a, _) :: xs -> a :: xs
  | _ -> Failed :: []


let cdr s =
  match s with
  | Pair (_, b) :: xs -> b :: xs
  | _ -> Failed :: []


let compare_pair s =
  match s with
  | Pair (xa, xb) :: Pair (ya, yb) :: xs -> begin
    match xa, xb, ya, yb with
    | T Ct Int ixa, T Ct Int ixb, T Ct Int iya, T Ct Int iyb -> begin
      if ixa = iya then compare (xb :: yb :: xs) else compare (xa :: ya :: xs)
    end
    | T Ct Nat ixa, T Ct Nat ixb, T Ct Nat iya, T Ct Nat iyb -> begin
      if Rnat.to_int ixa = Rnat.to_int iya then compare (xb :: yb :: xs) else compare (xa :: ya :: xs)
    end
    | _ -> Failed :: []
  end
  | _ -> Failed :: []


let empty_set s =
  match s with
  | Failed :: _ -> Failed :: []
  | _ -> T (Set []) :: s

let rec mem_set_aux t l =
  match l with
  | [] -> T (Ct (Bool false))
  | hd :: tl -> begin
    let s = compare (T (Ct t) :: T (Ct hd) :: []) in begin
      match s with
      | T Ct Int n :: [] ->
        if n = 1 then mem_set_aux t tl else begin
          if n = 0 then T (Ct (Bool true)) else T (Ct (Bool false))
        end
      | _ -> Failed
    end
  end


let mem_set s =
  match s with
  | T Ct t :: T Set l :: xs -> mem_set_aux t l :: xs
  | _ -> Failed :: []


let rec update_set_aux t b l =
  match l with
  | [] -> begin
    if b then t :: [] else []
  end
  | hd :: tl -> begin
    let s = compare (T (Ct t) :: T (Ct hd) :: []) in begin
      match s with
      | T Ct Int n :: [] ->
        if n = 1 then hd :: (update_set_aux t b tl) else begin
          if n = 0 then begin
            if b then l else tl
          end else begin
            if b then t :: hd :: tl else l
          end
        end
      | _ -> []
    end
  end


let update_set s =
  match s with
  | T Ct t :: T Ct Bool b :: T Set l :: xs -> T (Set (update_set_aux t b l)) :: xs
  | _ -> Failed :: []


let rec iter_set_aux body l s =
  match l with
  | [] -> s
  | hd :: tl -> iter_set_aux body tl (seq body (T (Ct hd) :: s))


let iter_set body s =
  match s with
  | T Set l :: xs -> iter_set_aux body l xs
  | _ -> Failed :: []


let rec size_set_aux l =
  match l with
  | [] -> Rnat.zero
  | _ :: tl -> Rnat.add (Rnat.succ (Rnat.zero)) (size_set_aux tl)


let size_set s =
  match s with
  | T Set l :: xs -> T (Ct (Nat (size_set_aux l))) :: xs
  | _ -> Failed :: []


let some s =
  match s with
  | T t :: xs -> T (Some t) :: xs
  | _ -> Failed :: []


let none s =
  match s with
  | Failed :: _ -> Failed :: []
  | _ -> T None :: s


let if_none bt bf s =
  match s with
  | T None :: xs -> seq bt xs
  | T Some x :: xs -> seq bf (T x :: xs)
  | _ -> Failed :: []

let cons s =
  match s with
  | T t :: List l :: xs -> List (t :: l) :: xs
  | _ -> Failed :: []


let nil s =
  match s with
  | Failed :: _ -> Failed :: []
  | _ -> List [] :: s


let if_cons bt bf s =
  match s with
  | List l :: xs -> begin
    match l with
    | [] -> seq bf xs
    | hd :: tl -> seq bt ((T hd) :: (List tl) :: xs)
  end
  | _ -> Failed :: []


let rec map_list_aux body l s =
  match l with
  | [] -> List [] :: s
  | hd :: tl -> let s' = seq body (T hd :: s) in begin
    match s' with
    | T x' :: xs' -> let s'' = map_list_aux body tl xs' in begin
      match s'' with
      | List l' :: xs'' -> (List (x' :: l')) :: xs''
      | _ -> Failed :: []
    end
    | _ -> Failed :: []
  end


let map_list body s =
  match s with
  | List l :: xs -> map_list_aux body l xs
  | _ -> Failed :: []

let rec size_list_aux l =
  match l with
  | [] -> Rnat.zero
  | _ :: tl -> Rnat.add (Rnat.succ (Rnat.zero)) (size_list_aux tl)


let size_list s =
  match s with
  | List l :: xs -> T (Ct (Nat (size_list_aux l))) :: xs
  | _ -> Failed :: []


let rec iter_list_aux body l s =
  match l with
  | [] -> s
  | hd :: tl -> iter_list_aux body tl (seq body (T hd :: s))

let iter_list body s =
  match s with
  | List l :: xs -> iter_list_aux body l xs
  | _ -> Failed :: []

let contract s p =
  match s with
  | T Ct Address a :: xs -> begin
    match p with
    | T Unit -> T (Some (Contract Unit)) :: xs
    | _ -> T None :: xs
  end
  | _ -> Failed :: []


let transfer_tokens s =
  match s with
  | T _ :: T Ct Mutez _ :: T Contract _ :: xs -> T Operation :: xs
  | _ -> Failed :: []


let _ = [ ]
